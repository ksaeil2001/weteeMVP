# CLAUDE.md

## 1. 프로젝트 개요

- 프로젝트명: 개인 과외 관리 통합 플랫폼 (가칭 WeTee)
- 목적:
  - 과외 선생님, 학생, 학부모가 겪는 **파편화된 도구, 불투명한 정산, 반복적인 행정 업무**를 한 곳에서 해결하는 통합 관리 서비스
  - 일정, 출결, 진도, 정산, 알림을 하나의 플랫폼에서 관리하여, 사용자가 **더 가치 있는 일(수업 준비, 학생 관리)에 집중**하도록 돕는 것
- 핵심 사용자:
  - 개인 과외 선생님
  - 과외를 맡기는 학부모
  - 학생 (중·고등학생 중심)

이 레포는 이 서비스를 위한 **MVP 1단계 기능(F-001~F-008)**의 프론트엔드, 백엔드, 데이터베이스를 구현하기 위한 코드 저장소다.

---

## 2. 문서 구조와 우선순위

이 레포에는 기획/설계 문서가 여러 개 있다. Claude는 코드를 작성하기 전에 아래 문서들을 **이 순서대로** 우선 읽는다.

1. `01_문제_정의_및_목표_설정.md`  
   - 해결하려는 문제, 타깃 사용자, 성공 기준이 적힌 최상위 기획 문서.

2. `UX_UI_설계서.md`  
   - 전체 화면 목록, 사용자 플로우, 공통 레이아웃, 디자인 시스템, 공통 컴포넌트(Button, Card, Input, Badge 등)를 정의한 UX/UI 문서.  
   - 어떤 화면을 어디에 두고, 어떤 패턴/컴포넌트를 써야 하는지는 이 문서를 최우선으로 따른다. :contentReference[oaicite:0]{index=0}

3. 기능 명세서 `F-001` ~ `F-008`  
   - 기능별 시나리오, 권한, 예외 케이스, 필수/선택 입력 항목, 세부 UI 요구사항.

4. `API_명세서.md`  
   - 프론트엔드와 백엔드 사이의 REST API 계약(엔드포인트, 요청/응답 스키마, 에러 코드 등).

5. `데이터베이스_설계서.md`  
   - PostgreSQL 기반 테이블·관계·인덱스 구조.

6. `기술스택_설계서.md`  
   - 프론트엔드/백엔드/인프라 전체 아키텍처와 사용 기술·버전, 비기능 요구사항.
   - 
### 2.1 문서 해석 우선순위

- 서비스 전체 방향, 문제 정의, 페르소나  
  → `01_문제_정의_및_목표_설정.md`

- 화면 구조, 네비게이션, 공통 레이아웃, 컴포넌트, 색/폰트/간격, 인터랙션 패턴  
  → `UX_UI_설계서.md` 우선, 필요 시 기능 명세서의 UI 요구사항을 보완적으로 사용 :contentReference[oaicite:1]{index=1}

- 비즈니스 규칙, 권한, 예외 플로우  
  → 기능 명세서 `F-001` ~ `F-008`

- 요청/응답 스키마, 에러 코드  
  → `API_명세서.md`

- 테이블/관계 구조  
  → `데이터베이스_설계서.md`

- 사용 기술 버전, 인프라 구조, 비기능 요구사항  
  → `기술스택_설계서.md`

### 2.2 충돌 발생 시 처리 규칙

문서 내용이 서로 충돌할 때 Claude는 다음 규칙을 따른다.

1. **무엇을 / 언제 / 누가 해야 하는지**(업무 규칙, 권한, 시나리오)는 기능 명세서가 UX/UI 설계서보다 우선이다.  
2. **어떻게 보여줄지**(레이아웃, 화면 구조, 공통 컴포넌트, 색/폰트/간격, 애니메이션)는 UX_UI_설계서가 기능 명세서보다 우선이다. :contentReference[oaicite:2]{index=2}  
3. API나 DB 설계를 바꿔야 할 정도의 변경이 필요하면, 실제 코드 수정 전에 그 이유와 영향을 코드 또는 설명에 TODO 형태로 남긴다.


### 문서 해석 우선순위

문서 간 내용이 충돌하거나 해석이 애매할 때는 다음 순서를 따른다.

1. `01_문제_정의_및_목표_설정.md` (문제·목표)
2. 기능 명세서 `F-001` ~ `F-008` (기능·플로우·UI 요구사항)
3. `API_명세서.md` (엔드포인트·요청/응답 형식)
4. `데이터베이스_설계서.md` (테이블·관계 구조)
5. `기술스택_설계서.md` (기술 선택·버전, 비기능 요구사항)

코드를 작성할 때는 **기능 명세서의 요구사항을 절대적으로 우선**하고, 다른 문서와 어긋나는 경우에는:
- 우선 기능 명세서를 기준으로 구현하되,
- 필요한 경우 “어떤 부분이 충돌하는지”를 주석 또는 설명으로 명확히 남긴다.

---

## 3. 구현 범위 (MVP 1단계)

MVP 1단계에서 구현해야 할 기능은 다음 8개다.

1. `F-001_회원가입_및_로그인.md`
2. `F-002_과외_그룹_생성_및_매칭.md`
3. `F-003_수업_일정_관리.md`
4. `F-004_출결_관리.md`
5. `F-005_수업_기록_및_진도_관리.md`
6. `F-006_수업료_정산.md`
7. `F-007_기본_프로필_및_설정.md`
8. `F-008_필수_알림_시스템.md`

### 반드시 **지금 구현하지 말아야 할 것들**

- 각 기능 명세서의 “개선 아이디어”, “향후 확장”, “2단계에서 고려” 등으로 표시된 내용
- AI 추천, 고급 통계/분석, 검색 고도화(Elasticsearch 중심 기능) 등 2단계 이후로 미뤄둔 기능
- 이메일/SMS 알림, 고급 알림 필터링 등 F-008에서 의도적으로 제외한 고급 옵션

이 내용들은 코드에 **훅(hook) 정도의 여지만 남기고**, 실제 구현은 하지 않는다.

---

## 4. 기술 스택 요약 (실제 구현 기준)

이 레포에서 Claude가 가정해야 할 기본 기술 스택은 다음과 같다.

### 백엔드

- 언어 및 프레임워크: Python 3.11 + FastAPI
- 주요 역할:
  - 인증/인가(JWT)
  - 그룹/일정/출결/수업 기록/정산/프로필/알림 관련 REST API 제공
  - 토스페이먼츠 Webhook 처리 (정산·결제 연동)
- 비기능 요구사항:
  - Pydantic 모델 기반 요청/응답 검증
  - 공통 에러 처리 미들웨어
  - Rate Limiting, 로깅, 모니터링 등은 기술스택 설계서 기준으로 최소 수준 반영

### 데이터베이스

- 엔진: PostgreSQL 15.x
- 핵심 테이블(요약):
  - `users`, `teachers`, `students`, `parents`
  - `groups`, `group_members`, `invite_codes`
  - `schedules`, `attendances`, `lesson_records`, `progress_records`
  - `payments`, `invoices`, `transactions`
  - `notifications`, `settings`, (필요 시) `login_history`
- 관계 구조와 상세 스키마는 `데이터베이스_설계서.md`를 따른다.

### 프론트엔드

- 클라이언트:
  - 모바일 앱: React Native
  - 웹 앱: React 기반 SPA
- 역할:
  - F-001~F-008에서 정의한 화면/플로우/상태를 구현
  - 모든 데이터는 백엔드 API를 통해 가져오며, 프론트엔드는 비즈니스 규칙을 새로 정의하지 않는다.

(이 레포에서 실제로 어떤 클라이언트를 우선 구현할지는, 디렉터리 구조 또는 추가 설명에 따라 조정한다. 명시가 없으면 우선 “웹(React)용 관리 화면”을 기준으로 설계해도 된다.)

---

## 5. 개발 원칙 (Claude가 반드시 지켜야 할 규칙)

1. **문서를 먼저 읽고 요약한 뒤 코드를 작성한다.**
   - 단일 기능을 구현하더라도 관련 기능 명세서(F-00X), API, DB 문서를 먼저 읽고,
   - “이 기능이 해결하려는 문제”와 “핵심 플로우”를 2~3줄로 정리한 뒤 구현을 시작한다.

2. **기능 명세서의 “UI 요구사항”을 그대로 반영한다.**
   - 화면 구성, 필수 버튼, 필드, 상태, 권한(누가 보고/누가 수정하는지)은 기능 명세서의 UI 요구사항 섹션을 최우선으로 따른다.
   - 모호한 부분이 있으면 `01_문제_정의_및_목표_설정.md`의 페르소나·상황을 참고해 합리적인 기본값을 선택한다.
   - 2. **모든 화면/컴포넌트는 UX_UI_설계서의 디자인 시스템을 따른다.**  
   - 가능한 한 `UX_UI_설계서.md`에 정의된 공통 컴포넌트(Button, Input, Card, Badge, Toast 등)를 우선 사용하고, 같은 역할의 새 컴포넌트를 만들지 않는다. :contentReference[oaicite:3]{index=3}  
   - 색상, 타이포그래피, 간격, 아이콘, 그림자 값은 UX_UI 설계서의 디자인 토큰(Primary/Secondary 색, Gray 팔레트, 텍스트 스타일, spacing 규칙 등)을 그대로 반영한다.  
   - 새로운 컴포넌트가 필요하다면, 우선 UX_UI 설계서의 패턴을 재조합해서 해결하고, 정말 새 타입이 필요할 때만 “왜 필요한지”를 주석으로 설명한다.


3. **비즈니스 로직은 프론트엔드에서 새로 발명하지 않는다.**
   - “어떤 값이 언제 생성/변경되는지”는 가능한 한 백엔드에서 책임진다.
   - 프론트엔드는 입력·검증·표시·상태 관리에 집중하고, 핵심 규칙은 API 스펙과 DB 설계를 따른다.

4. **API 명세와 DB 설계를 가능한 한 그대로 사용한다.**
   - 새 엔드포인트를 만들기보다, `API_명세서.md`에 정의된 엔드포인트를 우선 사용한다.
   - DB에 없는 필드/테이블을 임의로 만들지 말고, 필요하면:
     - 우선 임시 필드나 TODO 주석으로 표시하고,
     - “어떤 기능 때문에 어떤 필드/테이블이 필요해 보이는지”를 명시한다.

5. **작은 단위로 작업하고, 각 단계마다 무엇을 했는지 설명한다.**
   - “디렉터리 구조 설계 → 모델/스키마 정의 → API 라우트 구현 → 프론트엔드 화면/컴포넌트 구현 → 간단한 테스트” 순서를 권장한다.
   - 한 번에 레포 전체를 갈아엎는 큰 변경보다, 기능 단위·화면 단위로 점진적으로 구현한다.

6. **문서의 설계 원칙을 깨지 않는다.**
   - 각 문서에 정의된 “중복 금지, 추상화 레벨, 영향 범위 최소화” 원칙을 존중한다.
   - 예를 들어:
     - 기능 명세서에 있는 내용을 API 문서에 중복 서술하지 말고, 필요한 경우 “참조”만 한다.
     - DB 설계 내용을 기능 명세서에 다시 쓰려고 하지 않는다.

---

## 6. 기능별 구현 가이드

각 기능을 구현할 때 Claude가 기본적으로 따라야 할 체크리스트를 정리한다.

### F-001 회원가입 및 로그인

- 참고 문서:
  - `F-001_회원가입_및_로그인.md`
  - `API_명세서.md`의 F-001 관련 섹션
  - `데이터베이스_설계서.md`의 `users`, `teachers`, `students`, `parents` 테이블
- 구현 목표:
  - 이메일/비밀번호 기반 회원가입, 로그인, 로그아웃
  - 역할(선생님/학부모/학생) 선택 및 저장
  - 비밀번호 재설정(가능하면 토큰 기반 플로우까지 고려)
- 주의점:
  - 무차별 대입 공격 방지 (Rate Limiting, 잠금 정책 등)
  - JWT 기반 인증 구조 및 토큰 저장 위치(클라이언트)

### F-002 과외 그룹 생성 및 매칭

- 참고 문서:
  - `F-002_과외_그룹_생성_및_매칭.md`
  - `API_명세서.md`의 F-002 관련 섹션
  - `데이터베이스_설계서.md`의 `groups`, `group_members`, `invite_codes`
- 구현 목표:
  - 선생님이 과외 그룹 생성, 학생·학부모 초대/매칭
  - 그룹 정보(과목, 학년, 요일/시간 등) 관리
- 주의점:
  - 권한(그룹 생성·수정은 선생님, 조회는 학생/학부모)
  - 초대 코드/링크의 유효기간 및 상태 관리

### F-003 수업 일정 관리

- 참고 문서:
  - `F-003_수업_일정_관리.md`
  - 관련 API 및 DB의 `schedules`, `attendances` 등
- 구현 목표:
  - 정규 수업 일정 등록, 수정, 삭제
  - 보강 수업 일정 관리
  - 달력 뷰에서 수업 일정 시각화
- 주의점:
  - 반복 일정 규칙 처리
  - 시간대, 휴일, 보강·결석 처리와의 연계

### F-004 출결 관리

- 참고 문서:
  - `F-004_출결_관리.md`
  - `attendances` 테이블
- 구현 목표:
  - 선생님의 출석/지각/결석/보강 표시 기능
  - 학생·학부모는 조회만 가능
- 주의점:
  - 일정(F-003) 및 정산(F-006)과의 데이터 연계
  - 상태 변경 히스토리가 필요한지 여부

### F-005 수업 기록 및 진도 관리

- 참고 문서:
  - `F-005_수업_기록_및_진도_관리.md`
  - `lesson_records`, `progress_records`, `textbooks`
- 구현 목표:
  - 수업별 요약, 진도, 숙제 기록
  - 학부모·학생이 확인할 수 있는 뷰 제공
- 주의점:
  - 한 수업에서 여러 교재·진도 기록이 가능하다는 점 반영
  - 나중에 검색/필터링을 고려한 데이터 구조 유지

### F-006 수업료 정산

- 참고 문서:
  - `F-006_수업료_정산.md`
  - `payments`, `invoices`, `transactions`
  - 토스페이먼츠 관련 부분 (Webhook, 결제 상태)
- 구현 목표:
  - 수업 횟수·출결 정보를 바탕으로 한 자동 정산
  - 청구서 생성, 결제 상태 조회
- 주의점:
  - 정산 로직의 소스 오브 트루스는 “출결 + 일정” 데이터
  - 법적 보관 기간, 영수증/거래내역 보관 정책 반영

### F-007 기본 프로필 및 설정

- 참고 문서:
  - `F-007_기본_프로필_및_설정.md`
  - `users`, `settings`, (필요 시) `login_history`
- 구현 목표:
  - 사용자 기본 정보(이름, 연락처, 사진 등) 관리
  - 언어, 알림, 보안 설정 등 환경 설정 화면
- 주의점:
  - “읽기 모드 / 수정 모드 분리” 등 UI 정책 준수
  - 로그인 기록 조회 기능이 필요한 경우, DB 설계서의 `login_history` 테이블 정의를 따른다.

### F-008 필수 알림 시스템

- 참고 문서:
  - `F-008_필수_알림_시스템.md`
  - `notifications` 테이블
- 구현 목표:
  - 수업 일정, 보강, 숙제, 정산 등 핵심 이벤트에 대한 푸시 알림
  - 알림 리스트 화면, 읽음 처리, on/off 설정
- 주의점:
  - MVP에서는 푸시 알림만, 간단한 on/off 수준의 설정만 지원 (고급 필터링은 제외)
  - 알림 보관 기간(예: 90일 등)을 정책대로 적용

---

## 7. Claude Code에서의 작업 방식

이 레포를 Claude Code에서 열고 작업할 때는 다음 절차를 따른다.

1. 기능·화면 식별  
   - 사용자의 요청에서 다루려는 기능 ID(F-00X)와 화면 ID(S-0xx)를 먼저 파악한다.  
   - 해당 기능 명세서(F-00X), UX_UI_설계서의 해당 화면, 관련 API/DB 설계서를 확인한다.

2. 문서 읽기 및 요약  
   - `01_문제_정의_및_목표_설정.md`, `UX_UI_설계서.md` 중 이번 작업과 직접 관련된 부분을 짧게 요약한다.  
   - 해당 F-00X 기능 명세서에서 포함되는 사용자 플로우, UI 요구사항, 권한 규칙을 정리한다.  
   - `API_명세서.md`, `데이터베이스_설계서.md`에서 사용할 엔드포인트, 테이블, 주요 필드만 추려서 목록으로 만든다.

3. 구현 범위 정의  
   - “이번 작업에서 어디까지 구현할지”를 한 문단으로 선언한다.  
   - 예시: “이번 작업에서는 F-003 중 S-012(선생님용 수업 일정 등록/수정 화면)과 해당 화면에서 사용하는 일정 CRUD API까지만 구현한다.”

4. 계획 수립(작은 단계로 쪼개기)  
   - 프론트엔드와 백엔드를 포함한 전체 작업을 3~5개의 작은 단계로 나눈다.  
   - 각 단계는 최대 5~7개 파일만 수정하도록 설계하고, 단계별로 실행할 테스트 명령과 수동 확인 방법을 함께 적는다.

5. 코드 작성 및 반복 루프  
   - 한 번에 **1단계만** 실제로 수행한다.  
   - 각 단계에서 다음 정보를 반드시 출력한다.  
     - 수정·추가된 파일 목록  
     - 각 파일의 핵심 변경 내용 요약  
     - 실행해야 할 테스트/빌드 명령어 (예: `cd backend && pytest`, `cd web && npm test`)  
     - 사용자가 눈으로 확인할 수 있는 동작 시나리오  
   - 사용자의 피드백(테스트 결과, UI/UX 의견 등)을 받은 뒤에만 다음 단계로 진행한다.

6. 백엔드·프론트엔드 구현 순서  
   - **백엔드**  
     - Pydantic 스키마/도메인 모델  
     → 라우터(엔드포인트)  
     → 서비스/비즈니스 로직  
     → 간단한 테스트(단위/통합) 순으로 구현한다.  
   - **프론트엔드**  
     - `UX_UI_설계서.md`의 레이아웃/컴포넌트 규칙을 따르는 페이지/스크린(S-0xx) 뼈대를 먼저 만들고,  
     - 재사용 가능한 컴포넌트  
     → 상태 관리  
     → API 연동  
     → 에러/로딩 처리 순으로 구현한다.

7. 화면 ID(S-0xx)와 코드 매핑  
   - 새로운 화면이나 컴포넌트를 구현할 때는, 반드시 `UX_UI_설계서.md`에 정의된 화면 ID(S-0xx)를 확인한다.  
   - 각 화면의 루트 컴포넌트 파일 상단에 주석으로 해당 ID와 관련 기능을 명시한다.

     예시:
     // Screen S-012: 달력 메인 화면 (홈)
     // 관련 기능: F-003 수업 일정 관리

   - UX_UI_설계서에 없는 새로운 화면이 필요해 보일 경우, 먼저 기존 S-0xx 패턴을 재사용할 수 있는지 검토한다.  
   - 정말 새 화면이 필요하다면:
     - 제안하는 새 화면의 목적과 플로우를 설명하고,
     - 임시 S-ID를 붙여 사용한 뒤, 추후 `UX_UI_설계서.md`에 반영해야 한다는 TODO를 남긴다.

8. 작업 결과 정리  
   - 각 작업 세션의 마지막에는 다음 내용을 짧게 요약한다.  
     - 어떤 문서를 근거로 무엇을 구현했는지  
     - 아직 남아 있는 TODO와 다음 단계 후보  
     - API/DB/UX 설계 차원에서 추후 문서에 반영해야 할 제안 사항


   - 어떤 부분이 아직 TODO인지,
   - 어떤 확장 포인트를 남겨두었는지 정리해서 설명한다.
