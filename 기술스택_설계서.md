# 과외 관리 플랫폼 - 기술 스택 설계서

**버전**: v1.1  
**작성일**: 2025-11-05  
**최종 수정일**: 2025-11-11  
**작성자**: AI Assistant  
**문서 타입**: 기술 아키텍처

---

## 📌 문서 작성 원칙 준수

- ✅ **중복 금지**: 기능 상세는 기능 명세서에만, 데이터 구조는 DB 설계서에만
- ✅ **추상화 레벨 준수**: 이 문서는 "어떤 기술로 구현할 것인가" (How - Technology)
- ✅ **영향 범위 최소화**: 기술 스택 변경 시 이 문서만 수정

---

## 1. 전체 아키텍처 개요

### 시스템 구성도

```
┌─────────────────────────────────────────────────────────────┐
│                         사용자 (Client)                        │
│                                                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │   iOS 앱      │  │  Android 앱   │  │   Web 앱      │       │
│  │ (React Native)│  │(React Native) │  │   (React)     │       │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘       │
└─────────┼──────────────────┼──────────────────┼──────────────┘
          │                  │                  │
          └──────────────────┴──────────────────┘
                             │ HTTPS
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                  API Gateway (Kong 3.4)                       │
│                  (인증, 로깅, Rate Limiting)                   │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                    Backend (FastAPI + Python)                 │
│                                                                │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐       │
│  │  인증     │ │  그룹    │ │  수업    │ │  정산    │       │
│  │  서비스   │ │  서비스  │ │  서비스  │ │  서비스  │       │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘       │
│                                                                │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐                     │
│  │  알림     │ │  결제    │ │  파일    │                     │
│  │  서비스   │ │  서비스  │ │  서비스  │                     │
│  └──────────┘ └──────────┘ └──────────┘                     │
└──────────────────────────┬──────────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ▼                  ▼                  ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ PostgreSQL   │  │    Redis     │  │  S3 Storage  │
│   (주 DB)     │  │   (캐시)      │  │  (파일)       │
└──────────────┘  └──────────────┘  └──────────────┘
        │
        ▼
┌──────────────┐
│Elasticsearch │
│  8.10 (검색) │
└──────────────┘

         외부 서비스 연동
┌──────────────┐  ┌──────────────┐
│   FCM/APNS   │  │    PG사       │
│   (푸시알림)  │  │  (토스페이)   │
└──────────────┘  └──────────────┘
```

### 아키텍처 선택 이유

**마이크로서비스 지향 모놀리스 (Modular Monolith)**:
- **선택 근거**: MVP 단계에서는 완전한 마이크로서비스가 과도함
- **장점**: 
  - 개발 속도 빠름 (서비스 간 통신 오버헤드 없음)
  - 디버깅 용이
  - 배포 간편
- **확장성**: 각 모듈을 독립 서비스로 분리 가능하게 설계
- **트레이드오프**: 초기 확장성 < 빠른 출시

---

## 2. 프론트엔드 (Mobile & Web)

### 2.1 모바일 앱: React Native

**선택한 기술**: React Native 0.72.6

**선택 근거**:
1. **Cross-Platform 개발**:
   - iOS + Android를 하나의 코드베이스로 개발
   - 개발 리소스 50% 절감
   - 참고: F-001~F-008 모든 기능이 iOS/Android 동일하게 동작해야 함

2. **빠른 개발 속도**:
   - Hot Reload로 개발 사이클 단축
   - 풍부한 UI 라이브러리 (React Native Paper, NativeBase)
   - 참고: MVP 3-4개월 안에 출시 목표

3. **커뮤니티 & 생태계**:
   - 가장 큰 크로스플랫폼 커뮤니티
   - 서드파티 라이브러리 풍부 (결제, 알림, 지도 등)
   - 참고: F-006 결제 연동, F-008 푸시알림 등 외부 서비스 많음

**주요 라이브러리**:
```javascript
{
  "dependencies": {
    "react-native": "^0.72.0",
    "react-navigation": "^6.0",      // 화면 네비게이션 (F-001~F-008 모든 화면 전환)
    "axios": "^1.4.0",               // API 통신
    "react-query": "^3.39.0",        // 서버 상태 관리 (캐싱, 자동 리프레시)
    "zustand": "^4.3.0",             // 클라이언트 상태 관리 (간단함)
    "react-native-calendars": "^1.1299.0",  // F-003 캘린더 UI
    "react-native-push-notification": "^8.1.1",  // F-008 푸시알림
    "react-native-iap": "^12.10.0",  // F-006 앱 내 결제 (미래 확장)
    "react-native-image-picker": "^5.3.0",  // F-007 프로필 사진 업로드
    "react-native-chart-kit": "^6.12.0",     // F-006 정산 그래프
  }
}
```

**대안과 비교**:
| 기술 | 장점 | 단점 | 선택 이유 |
|------|------|------|-----------|
| **React Native** | Cross-platform, 빠른 개발, 큰 커뮤니티 | 성능 한계, 네이티브 모듈 필요 시 복잡 | ✅ MVP에 최적, 확장 가능 |
| Flutter | 고성능, 아름다운 UI | 작은 생태계, Dart 학습 곡선 | ❌ 팀 숙련도 낮음 |
| Native (Swift/Kotlin) | 최고 성능 | 2배 개발 시간, 비용 증가 | ❌ MVP 단계에 과도 |

---

### 2.2 웹 앱: React (선택적, 2단계)

**선택한 기술**: React 18.2 + Next.js 14

**선택 근거**:
- MVP는 모바일 우선이지만, 선생님들이 PC에서 관리하고 싶어할 수 있음
- React Native와 많은 로직 공유 가능 (같은 React 생태계)
- SEO 필요 시 Next.js로 SSR 지원

**우선순위**: 2단계 (모바일 검증 후)

---

## 3. 백엔드 (API Server)

### 3.1 프레임워크: FastAPI

**선택한 기술**: FastAPI 0.104.1 (Python 3.11.6)

**선택 근거**:
1. **Python 기반**:
   - 사용자의 선호 언어 ✅
   - 데이터 처리 라이브러리 풍부 (Pandas, NumPy)
   - 참고: F-006 정산 계산, F-005 진도 통계 등 데이터 연산 많음

2. **고성능 비동기**:
   - ASGI 기반, async/await 지원
   - Django보다 3-5배 빠른 응답 속도
   - 참고: F-008 알림 발송, F-006 실시간 결제 처리 등 동시성 중요

3. **자동 문서화**:
   - Swagger UI 자동 생성 (/docs)
   - 프론트엔드 개발자와 협업 용이
   - API 명세서 따로 작성 불필요

4. **타입 힌팅 & 검증**:
   - Pydantic으로 자동 입력 검증
   - 타입 안정성 높음 (버그 감소)

**프로젝트 구조**:
```
backend/
├── app/
│   ├── main.py                    # FastAPI 앱 초기화
│   ├── config.py                  # 환경 변수, 설정
│   ├── database.py                # DB 연결 (SQLAlchemy)
│   ├── dependencies.py            # 의존성 주입 (인증 등)
│   │
│   ├── models/                    # SQLAlchemy ORM 모델
│   │   ├── user.py                # F-001 사용자
│   │   ├── group.py               # F-002 그룹
│   │   ├── schedule.py            # F-003 일정
│   │   ├── attendance.py          # F-004 출결
│   │   ├── lesson_record.py       # F-005 수업 기록
│   │   ├── payment.py             # F-006 정산
│   │   └── notification.py        # F-008 알림
│   │
│   ├── schemas/                   # Pydantic 스키마 (Request/Response)
│   │   ├── user.py
│   │   ├── group.py
│   │   └── ...
│   │
│   ├── routers/                   # API 라우터 (각 기능별)
│   │   ├── auth.py                # F-001 인증 API
│   │   ├── groups.py              # F-002 그룹 API
│   │   ├── schedules.py           # F-003 일정 API
│   │   ├── attendance.py          # F-004 출결 API
│   │   ├── lesson_records.py      # F-005 수업 기록 API
│   │   ├── payments.py            # F-006 정산 API
│   │   ├── profiles.py            # F-007 프로필 API
│   │   └── notifications.py       # F-008 알림 API
│   │
│   ├── services/                  # 비즈니스 로직
│   │   ├── auth_service.py
│   │   ├── payment_service.py     # 정산 계산 로직
│   │   ├── notification_service.py # 알림 발송 로직
│   │   └── ...
│   │
│   └── utils/                     # 유틸리티
│       ├── security.py            # 비밀번호 해싱, JWT
│       ├── email.py               # 이메일 발송
│       └── validators.py          # 커스텀 검증
│
├── tests/                         # 테스트 코드
│   ├── test_auth.py
│   ├── test_payment.py
│   └── ...
│
├── alembic/                       # DB 마이그레이션
│   └── versions/
│
├── requirements.txt               # Python 패키지
└── Dockerfile                     # 컨테이너 이미지
```

**주요 패키지**:
```python
# requirements.txt
fastapi==0.100.0
uvicorn[standard]==0.23.0     # ASGI 서버
sqlalchemy==2.0.0             # ORM
alembic==1.11.0               # DB 마이그레이션
pydantic==2.0.0               # 데이터 검증
python-jose[cryptography]==3.3.0  # JWT 토큰
passlib[bcrypt]==1.7.4        # 비밀번호 해싱
python-multipart==0.0.6       # 파일 업로드
aioredis==2.0.1               # Redis 비동기 클라이언트
celery==5.3.0                 # 백그라운드 작업 (알림, 정산)
boto3==1.28.0                 # AWS S3 (파일 저장)
httpx==0.24.0                 # 외부 API 호출 (PG사, FCM)
```

**대안과 비교**:
| 프레임워크 | 장점 | 단점 | 선택 이유 |
|-----------|------|------|-----------|
| **FastAPI** | 빠름, 현대적, 자동 문서화 | 역사 짧음, Django만큼 기능 많지 않음 | ✅ MVP에 최적, 빠른 개발 |
| Django | 완성도 높음, Admin, ORM | 무겁고 느림, 비동기 지원 약함 | ❌ 오버엔지니어링 |
| Flask | 가벼움, 유연함 | 모든 걸 직접 구현, 표준 없음 | ❌ 생산성 낮음 |

---

### 3.2 인증 & 보안

**JWT (JSON Web Token)**:
- **Access Token**: 15분 유효, 모든 API 요청에 사용
- **Refresh Token**: 7일 유효, Access Token 갱신용
- 참고: F-001 로그인 유지, F-007 로그인 기록

**비밀번호 해싱**: bcrypt (cost factor 12)
- 참고: F-001 비밀번호 8자 이상 규칙

**HTTPS 필수**: Let's Encrypt SSL 인증서
- 모든 통신 암호화
- 참고: F-006 결제 정보 보안

**Rate Limiting**: 
- 로그인 API: 5회/분 (무차별 대입 방지)
- 일반 API: 100회/분
- 참고: F-001 무차별 대입 공격 방지

---

## 4. 데이터베이스

### 4.1 주 데이터베이스: PostgreSQL

**선택한 기술**: PostgreSQL 15.4

**선택 근거**:
1. **관계형 데이터 완벽 지원**:
   - 사용자-그룹-일정-출결-정산의 복잡한 관계
   - Foreign Key, Transaction 필수
   - 참고: F-002 그룹 매칭, F-004 출결 → F-006 정산 연계

2. **JSON 타입 지원**:
   - 유연한 스키마 필요한 데이터 (F-005 수업 기록, F-007 설정)
   - JSONB로 빠른 쿼리 가능

3. **확장성 & 성능**:
   - 파티셔닝, 복제, 샤딩 지원
   - 수백만 레코드도 빠른 쿼리 (인덱스 최적화)

4. **오픈소스 & 무료**:
   - 라이센스 비용 없음
   - AWS RDS, GCP Cloud SQL 호환

**핵심 테이블 개요** (상세는 DB 설계서 참조):
```
users                 # F-001 사용자
├── teachers          # 선생님 추가 정보
├── students          # 학생 추가 정보
└── parents           # 학부모 추가 정보

groups                # F-002 과외 그룹
├── group_members     # 그룹-사용자 관계
└── invite_codes      # 초대 코드

schedules             # F-003 수업 일정
├── regular_schedules # 정규 일정
└── makeup_schedules  # 보강 일정

attendances           # F-004 출결 기록

lesson_records        # F-005 수업 기록
└── progress_records  # 진도 기록

payments              # F-006 정산
├── invoices          # 청구서
└── transactions      # 결제 내역

notifications         # F-008 알림
```

**대안과 비교**:
| 데이터베이스 | 장점 | 단점 | 선택 이유 |
|-------------|------|------|-----------|
| **PostgreSQL** | 관계형 완벽, JSON 지원, 무료 | 초기 설정 복잡 | ✅ 과외 관리에 최적 |
| MySQL | 간단, 널리 사용됨 | JSON 기능 약함, FK 제약 느림 | ❌ 기능 부족 |
| MongoDB | 스키마 유연, 빠른 쓰기 | 관계 처리 약함, 트랜잭션 복잡 | ❌ 관계형 데이터 많음 |

---

### 4.2 캐시: Redis

**선택한 기술**: Redis 7.2.3

**사용 목적**:
1. **세션 저장**: JWT Refresh Token
2. **캐싱**: 자주 조회되는 데이터 (F-002 그룹 정보, F-007 프로필)
3. **Rate Limiting**: API 요청 횟수 제한
4. **실시간 데이터**: 온라인 사용자 수, 읽지 않은 알림 수

**캐싱 전략**:
- **Cache-Aside**: 읽기 위주 데이터 (프로필, 그룹 정보)
- **Write-Through**: 쓰기 후 캐시 업데이트 (알림 카운트)
- **TTL**: 5분 (프로필), 1분 (알림 카운트)

---

### 4.3 검색: Elasticsearch (2단계)

**선택한 기술**: Elasticsearch 8.10.4

**사용 목적**:
- F-005 수업 기록 전체 검색
- F-002 그룹/학생 이름 검색
- 2단계에서 추가 예정 (MVP는 PostgreSQL의 `LIKE` 쿼리로 충분)

---

## 5. 파일 저장소

### AWS S3 (또는 호환 스토리지)

**선택한 기술**: AWS S3 / MinIO (로컬 개발용)

**저장할 파일**:
- F-007: 프로필 사진
- F-005: 수업 자료 첨부파일 (2단계)
- F-006: 영수증 PDF

**파일 구조**:
```
tutoring-platform-bucket/
├── profiles/
│   ├── {user_id}/
│   │   └── avatar.jpg
│
├── lesson-materials/
│   ├── {group_id}/
│   │   ├── {lesson_id}/
│   │   │   ├── material1.pdf
│   │   │   └── material2.png
│
└── receipts/
    ├── {payment_id}/
    │   └── receipt.pdf
```

**보안**:
- Pre-signed URL (1시간 유효)
- Private 버킷 (직접 접근 불가)
- CDN (CloudFront) 연동 (이미지 빠른 로딩)

---

## 6. 외부 서비스 연동

### 6.1 결제 (F-006)

**선택한 PG사**: 토스페이먼츠 (Payments API v1)

**선택 근거**:
1. **딥링크 결제 지원**: 앱 내에서 바로 결제 (토스앱, 카카오페이, 네이버페이)
2. **수수료 저렴**: 3.3% (신용카드), 2.8% (간편결제)
3. **개발 편의성**: RESTful API, Python SDK, 좋은 문서
4. **법적 안전**: PG사 에스크로 (구매안전서비스)

**SDK 버전**: 
- Python: `tosspayments==1.3.0`
- React Native: `@tosspayments/payment-sdk-react-native==1.1.0`

**결제 플로우**:
```
1. 학부모가 "결제하기" 탭
2. Backend가 토스페이먼츠에 결제 요청 (주문번호 생성)
3. 토스페이먼츠가 결제 URL 반환
4. 앱이 딥링크로 토스앱 열기 (또는 카카오페이, 네이버페이)
5. 사용자가 결제 완료
6. 토스페이먼츠가 Backend에 Webhook 전송
7. Backend가 결제 성공 처리 → 선생님/학부모 알림
```

**대안**:
- 이니시스, KG이니시스: 구식 UI, API 복잡
- 나이스페이: 수수료 높음 (4%)
- 페이플(Payple): 작은 회사, 안정성 우려

---

### 6.2 푸시 알림 (F-008)

**선택한 서비스**: Firebase Cloud Messaging (FCM) + APNs

**선택 근거**:
1. **무료**: 무제한 푸시 전송
2. **크로스플랫폼**: Android (FCM) + iOS (APNs via FCM)
3. **신뢰성**: Google 인프라, 99.9% uptime
4. **React Native 라이브러리**: `react-native-firebase` 완벽 지원

**SDK 버전**:
- Python Admin SDK: `firebase-admin==6.2.0`
- React Native: `@react-native-firebase/messaging==18.6.1`

**알림 유형**:
- **데이터 알림**: 앱이 켜져 있을 때 바로 처리 (실시간 알림)
- **노티피케이션 알림**: 앱이 꺼져 있어도 OS가 표시

**알림 발송 로직**:
```python
# Celery 백그라운드 작업
@celery.task
def send_notification(user_ids, title, body, data):
    for user_id in user_ids:
        device_token = get_user_device_token(user_id)
        
        # 야간 시간 체크 (F-008 야간 알림 제한)
        if is_night_mode(user_id):
            schedule_for_morning(user_id, notification)
            continue
        
        # FCM 전송
        message = messaging.Message(
            notification=messaging.Notification(title=title, body=body),
            data=data,
            token=device_token,
        )
        messaging.send(message)
```

---

### 6.3 이메일 발송 (F-001, F-007)

**선택한 서비스**: SendGrid v3 API (또는 AWS SES)

**사용 목적**:
- F-001: 회원가입 인증 이메일
- F-007: 비밀번호 재설정 이메일
- F-006: 청구서 이메일 (선택적)

**SDK 버전**:
- Python: `sendgrid==6.11.0`

**선택 근거**:
- SendGrid: 무료 100통/일, 간단한 API
- AWS SES: 더 저렴 (0.1$/천 통), 하지만 설정 복잡

---

## 7. 인프라 & DevOps

### 7.1 클라우드: AWS

**선택한 플랫폼**: Amazon Web Services (AWS)

**선택 근거**:
1. **시장 점유율 1위**: 안정성, 레퍼런스 많음
2. **서비스 다양성**: RDS, S3, CloudFront, Lambda 등
3. **프리티어**: 12개월 무료 (EC2, RDS, S3)
4. **한국 리전**: Seoul (ap-northeast-2) - 낮은 지연시간

**사용할 AWS 서비스**:
- **EC2**: FastAPI 서버 (t3.medium, 2vCPU, 4GB RAM)
- **RDS**: PostgreSQL (db.t3.micro → db.t3.small)
- **S3**: 파일 저장소
- **CloudFront**: CDN (이미지 빠른 로딩)
- **Route 53**: DNS 관리
- **Certificate Manager**: SSL 인증서

**예상 비용** (월):
- EC2 (t3.medium): $30
- RDS (db.t3.micro): $15
- S3 + CloudFront: $5
- 기타: $10
- **총합: 약 $60/월 (₩78,000)**

**대안**:
- GCP: 비슷한 기능, 프리티어 작음
- Azure: 엔터프라이즈용, 과다
- Heroku: 간단하지만 비쌈, 확장성 낮음

---

### 7.2 배포: Docker + GitHub Actions

**컨테이너화**: Docker 24.0 + Docker Compose 2.23

**Base Image 버전**:
- Backend: `python:3.11.6-slim`
- Database (로컬): `postgres:15.4`
- Cache (로컬): `redis:7.2.3`

**Dockerfile 예시**:
```dockerfile
FROM python:3.11.6-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY ./app /app

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**CI/CD**: GitHub Actions (워크플로우 v2)

**배포 파이프라인**:
```
1. Git Push to main 브랜치
2. GitHub Actions 트리거
3. 테스트 실행 (pytest)
4. Docker 이미지 빌드
5. AWS ECR에 이미지 푸시
6. EC2에서 새 컨테이너 실행
7. 헬스체크 후 이전 컨테이너 종료
```

**배포 전략**: Blue-Green Deployment
- 무중단 배포
- 롤백 빠름 (이전 버전으로 스위치)

---

### 7.3 모니터링 & 로깅

**모니터링**: 
- **Sentry 23.10**: 에러 추적, 알림
  - Python SDK: `sentry-sdk==1.38.0`
- **AWS CloudWatch**: 서버 리소스 모니터링 (CPU, 메모리)

**로깅**: ELK Stack (2단계)
- Elasticsearch 8.10.4
- Logstash 8.10.4  
- Kibana 8.10.4
- MVP는 파일 로깅 + CloudWatch Logs

**알림**:
- 서버 에러 발생 → Slack 알림
- API 응답 시간 > 2초 → 알림
- DB 연결 실패 → 알림

---

## 8. 개발 환경

### 8.1 로컬 개발

**Docker Compose**로 전체 환경 구성:

```yaml
# docker-compose.yml
version: '3.8'
services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/tutoring
      - REDIS_URL=redis://redis:6379
  
  db:
    image: postgres:15.4
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=tutoring
    ports:
      - "5432:5432"
  
  redis:
    image: redis:7.2.3
    ports:
      - "6379:6379"
  
  minio:  # S3 대체 (로컬)
    image: minio/minio:RELEASE.2023-11-20T22-40-07Z
    ports:
      - "9000:9000"
    environment:
      - MINIO_ROOT_USER=minioadmin
      - MINIO_ROOT_PASSWORD=minioadmin
```

**실행 명령**:
```bash
# 전체 환경 시작
docker-compose up -d

# 백엔드만 재시작
docker-compose restart backend

# 로그 확인
docker-compose logs -f backend
```

---

### 8.2 버전 관리

**Git 브랜치 전략**: GitHub Flow (간단함)

```
main 브랜치 (프로덕션)
  ↑
feature/F-001-login (기능 개발)
feature/F-002-group
feature/F-003-schedule
...
```

**커밋 메시지 컨벤션**:
```
feat: F-001 로그인 API 구현
fix: F-006 정산 계산 버그 수정
docs: README 업데이트
refactor: 인증 로직 리팩토링
test: F-003 일정 생성 테스트 추가
```

---

## 9. 보안 고려사항

### 9.1 OWASP Top 10 대응

1. **Injection (SQL Injection)**:
   - SQLAlchemy ORM 사용 (파라미터화된 쿼리)
   - 사용자 입력 검증 (Pydantic)

2. **Broken Authentication**:
   - JWT + Refresh Token
   - 비밀번호 bcrypt 해싱
   - Rate Limiting (무차별 대입 방지)

3. **Sensitive Data Exposure**:
   - HTTPS 필수
   - 비밀번호 해싱
   - 환경 변수로 API 키 관리 (`.env`)

4. **XSS (Cross-Site Scripting)**:
   - React/React Native 기본 방어 (자동 이스케이핑)
   - 사용자 입력 sanitize

5. **CSRF (Cross-Site Request Forgery)**:
   - JWT 토큰 (쿠키 사용 안 함)
   - SameSite 쿠키 (미래 확장 시)

---

### 9.2 개인정보 보호

**GDPR/개인정보보호법 준수**:
- 사용자 동의 필수 (F-001 회원가입)
- 데이터 최소 수집 (필요한 것만)
- 탈퇴 시 개인정보 삭제 (F-007, 단 거래 기록은 5년 보관)
- 암호화: 비밀번호 (bcrypt), 민감 데이터 (AES-256)

---

## 10. 확장성 고려사항

### 10.1 현재 아키텍처의 한계

**예상 사용자**: 
- 6개월 후: 선생님 100명, 학생 400명
- 1년 후: 선생님 500명, 학생 2,000명

**현재 아키텍처로 처리 가능**:
- EC2 1대 + RDS 1대로 충분
- 예상 트래픽: 10,000 요청/일 (평균 0.1 req/s)
- DB 레코드: ~10만 건 (여유 있음)

---

### 10.2 확장 전략 (사용자 10배 증가 시)

**Phase 1: 수직 확장 (Vertical Scaling)**
- EC2: t3.medium → t3.large (4vCPU, 8GB RAM)
- RDS: db.t3.micro → db.t3.medium
- 예상 비용: $60 → $150/월

**Phase 2: 수평 확장 (Horizontal Scaling)**
- **로드 밸런서** (ALB): 여러 EC2 인스턴스로 트래픽 분산
- **Auto Scaling**: 트래픽에 따라 EC2 자동 증감
- **DB Read Replica**: 읽기 부하 분산 (PostgreSQL 슬레이브)
- **Redis Cluster**: 캐시 용량 확장

**Phase 3: 마이크로서비스 분리**
- 알림 서비스 독립: 별도 서버 (Celery Worker)
- 결제 서비스 독립: 별도 서버 (트랜잭션 격리)
- API Gateway: Kong으로 라우팅

---

## 11. 성능 목표

### 11.1 응답 시간

| API 엔드포인트 | 목표 응답 시간 | 현재 예상 |
|---------------|--------------|----------|
| F-001 로그인 | < 500ms | 300ms |
| F-002 그룹 조회 | < 200ms | 150ms (캐시) |
| F-003 일정 생성 | < 300ms | 200ms |
| F-004 출결 체크 | < 200ms | 150ms |
| F-005 수업 기록 생성 | < 500ms | 400ms (DB 쓰기) |
| F-006 청구서 발송 | < 1초 | 800ms (외부 API) |
| F-008 알림 발송 | < 2초 | 1.5초 (백그라운드) |

---

### 11.2 가용성

- **Uptime**: 99.5% (연간 다운타임 43.8시간)
- **백업**: 일일 DB 백업, 7일 보관
- **재해 복구**: RTO (복구 목표 시간) 4시간, RPO (복구 시점 목표) 1일

---

## 12. 기술 스택 선택의 트레이드오프 요약

### 선택한 것 vs 포기한 것

**FastAPI vs Django**:
- ✅ 얻은 것: 빠른 성능, 현대적 개발 경험
- ❌ 포기한 것: Django Admin (자체 관리 도구 만들어야 함)

**React Native vs Native**:
- ✅ 얻은 것: 개발 속도 2배, 비용 50% 절감
- ❌ 포기한 것: 최고 성능 (과외 앱은 성능 덜 중요)

**PostgreSQL vs MongoDB**:
- ✅ 얻은 것: 데이터 무결성, 트랜잭션
- ❌ 포기한 것: 스키마 유연성 (하지만 과외 데이터는 구조화됨)

**AWS vs Heroku**:
- ✅ 얻은 것: 확장성, 비용 효율
- ❌ 포기한 것: 간편한 배포 (하지만 Docker로 해결)

---

## 13. 다음 단계: DB 설계서와의 연계

이 기술 스택 설계서를 바탕으로, 다음 문서를 작성해야 합니다:

### DB 설계서에서 정의할 내용:
1. **테이블 스키마**: 각 필드의 타입, 제약조건
2. **관계 (FK)**: 어떤 테이블이 어떻게 연결되는가
3. **인덱스**: 어떤 컬럼에 인덱스를 생성할 것인가 (쿼리 최적화)
4. **파티셔닝**: 큰 테이블 (출결, 알림) 어떻게 분할할 것인가

### 기능 명세서 피드백:
- 기능 명세서 검토 후, 추가로 필요한 기술이 있는지 확인
- 예: F-005 진도 그래프 → Chart 라이브러리 필요 ✅ (이미 포함)
- 예: F-006 영수증 PDF → PDF 생성 라이브러리 필요 → **추가 필요!**

---

## 14. 추가로 필요한 기술 (기능 명세서 재검토 후)

### 14.1 PDF 생성 (F-006 영수증)

**선택한 라이브러리**: ReportLab (Python)

```python
# requirements.txt에 추가
reportlab==4.0.0
```

**사용 예시**:
```python
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas

def generate_receipt_pdf(payment_data):
    pdf = canvas.Canvas(f"receipts/{payment_data['id']}.pdf", pagesize=A4)
    pdf.drawString(100, 750, f"청구서 번호: {payment_data['id']}")
    pdf.drawString(100, 730, f"금액: {payment_data['amount']}원")
    # ... 더 많은 내용
    pdf.save()
```

---

### 14.2 이미지 리사이징 (F-007 프로필 사진)

**선택한 라이브러리**: Pillow (Python)

```python
# requirements.txt에 추가
Pillow==10.0.0
```

**사용 예시**:
```python
from PIL import Image

def resize_profile_image(image_path):
    img = Image.open(image_path)
    img.thumbnail((200, 200))  # 200x200으로 리사이징
    img.save(f"profiles/{user_id}_thumb.jpg")
```

---

## 15. 변경 이력

| 버전 | 날짜 | 변경 내용 | 작성자 |
|------|------|----------|--------|
| v1.0 | 2025-11-05 | 초안 작성 | AI Assistant |
| v1.1 | 2025-11-11 | 모든 기술 스택에 구체적인 버전 명시 (Low 이슈 #1 해결) | AI Assistant |

---

## 16. 참고 문서

- 기능 명세서: F-001 ~ F-008
- 문제 정의서: `01_문제_정의_및_목표_설정.md`
- **다음 작성**: DB 설계서 (`데이터베이스_설계서.md`)

---

**작성자 노트**: 

**v1.1 업데이트 (2025-11-11)**:
교차검토 문서의 Low 이슈 #1을 해결하여 모든 주요 기술 스택에 구체적인 버전을 명시했습니다. 이를 통해 개발 환경 구축 시 버전 충돌을 방지하고, 재현 가능한 개발 환경을 보장합니다.

**주요 명시된 버전**:
- 프론트엔드: React Native 0.72.6, React 18.2, Next.js 14
- 백엔드: FastAPI 0.104.1, Python 3.11.6, Uvicorn 0.23.0
- 데이터베이스: PostgreSQL 15.4, Redis 7.2.3, Elasticsearch 8.10.4
- 외부 서비스: Firebase Admin SDK 6.2.0, SendGrid 6.11.0, 토스페이먼츠 1.3.0
- DevOps: Docker 24.0, Docker Compose 2.23, Sentry 1.38.0

**v1.0 (2025-11-05)**:
이 기술 스택은 MVP 빠른 출시와 향후 확장성을 모두 고려했습니다. Python 생태계를 최대한 활용하면서, 실전에서 검증된 기술만 선택했습니다. 모든 선택에는 명확한 근거가 있으며, 기능 명세서의 요구사항을 100% 만족시킬 수 있습니다.
